{
  "descriptors": {
    "components": [
      {
        "id": "spoolDir",
        "component": "source",
        "type": "spoolDir",
        "name": "Spooling Directory Source",
        "description": "This source lets you ingest data by placing files to be ingested into a “spooling” directory on disk. This source will watch the specified directory for new files, and will parse events out of new files as they appear. The event parsing logic is pluggable. After a given file has been fully read into the channel, it is renamed to indicate completion (or optionally deleted).",
        "settings": {
          "spoolDir": {
            "type": "directory",
            "name": "Spooling directory",
            "description": "The directory from which to read files from.",
            "required": true
          },
          "fileSuffix": {
            "type": "string",
            "name": "File suffix",
            "description": "Suffix to append to completely ingested files",
            "default": ".COMPLETED",
            "required": false
          },
          "deletePolicy": {
            "type": "enum",
            "name": "Delete policy",
            "description": "When to delete completed files: never or immediate",
            "default": "never",
            "required": false
          },
          "fileHeader": {
            "type": "",
            "name": "File header",
            "description": "Whether to add a header storing the absolute path filename.",
            "default": "false",
            "required": false
          },
          "fileHeaderKey": {
            "type": "",
            "name": "File header key",
            "description": "Header key to use when appending absolute path filename to event header.",
            "default": "file",
            "required": false
          },
          "basenameHeader": {
            "type": "",
            "name": "Base name header",
            "description": "Whether to add a header storing the basename of the file.",
            "default": "false",
            "required": false
          },
          "basenameHeaderKey": {
            "type": "",
            "name": "Base name header key",
            "description": "Header Key to use when appending basename of file to event header.",
            "default": "basename",
            "required": false
          },
          "ignorePattern": {
            "type": "",
            "name": "Ignore pattern",
            "description": "Regular expression specifying which files to ignore (skip)",
            "default": "^$",
            "required": false
          },
          "trackerDir": {
            "type": "",
            "name": "Tracker directory",
            "description": "Directory to store metadata related to processing of files. If this path is not an absolute path, then it is interpreted as relative to the spoolDir.",
            "default": ".flumespool",
            "required": false
          },
          "consumeOrder": {
            "type": "",
            "name": "Consume order",
            "description": "In which order files in the spooling directory will be consumed oldest, youngest and random. In case of oldest and youngest, the last modified time of the files will be used to compare the files. In case of a tie, the file with smallest laxicographical order will be consumed first. In case of random any file will be picked randomly. When using oldest and youngest the whole directory will be scanned to pick the oldest/youngest file, which might be slow if there are a large number of files, while using random may cause old files to be consumed very late if new files keep coming in the spooling directory.",
            "default": "oldest",
            "required": false
          },
          "maxBackoff": {
            "type": "integer",
            "name": "Max Backoff",
            "description": "The maximum time (in millis) to wait between consecutive attempts to write to the channel(s) if the channel is full. The source will start at a low backoff and increase it exponentially each time the channel throws a ChannelException, upto the value specified by this parameter.",
            "default": 4000,
            "required": false
          },
          "batchSize": {
            "type": "integer",
            "name": "Batch size",
            "description": "Granularity at which to batch transfer to the channel",
            "default": 100,
            "required": false
          },
          "inputCharset": {
            "type": "",
            "name": "Input Charset",
            "description": "Character set used by deserializers that treat the input file as text.",
            "default": "UTF-8",
            "required": false
          },
          "decodeErrorPolicy": {
            "type": "",
            "name": "Decode error policy",
            "description": "What to do when we see a non-decodable character in the input file. FAIL: Throw an exception and fail to parse the file. REPLACE: Replace the unparseable character with the “replacement character” char, typically Unicode U+FFFD. IGNORE: Drop the unparseable character sequence.",
            "default": "FAIL",
            "required": false
          },
          "deserializer": {
            "type": "",
            "name": "Deserializer",
            "description": "Specify the deserializer used to parse the file into events. Defaults to parsing each line as an event. The class specified must implement EventDeserializer.Builder.",
            "default": "LINE",
            "required": false
          },
          "bufferMaxLines": {
            "type": "",
            "name": "Buffer max lines",
            "description": "(Obselete) This option is now ignored.",
            "default": "",
            "required": false
          },
          "bufferMaxLineLength": {
            "type": "integer",
            "name": "Input Charset",
            "description": "(Deprecated) Maximum length of a line in the commit buffer. Use deserializer.maxLineLength instead.",
            "default": 5000,
            "required": false
          },
          "selector.type": {
            "type": "",
            "name": "Selector type",
            "description": "replicating or multiplexing",
            "default": "replicating",
            "required": false
          },
          "interceptors": {
            "type": "",
            "name": "Interceptors",
            "description": "Space-separated list of interceptors",
            "default": "",
            "required": false
          }
        },
        "ports": {

        },
        "ui": {

        }
      }
    ]
  }
}